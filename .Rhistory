NODF_nulls <- net.null.nest.bin(nulls_r2d)
nulls <- nulls_r2d
net.null.metric <- list()
for (i in 1:length(nulls)) {
net.null.metric[[i]] = do.call('rbind',
lapply(nulls[[i]], networklevel, index = 'NODF'))
}
1:length(nulls)
nulls[[i]]
lapply(nulls[[i]], networklevel, index = 'NODF')
colSums(nulls[[i]])
lapply(NODF_nulls, networklevel, index = 'NODF')
NODF_nulls <- unlist(lapply(NODF_nulls, networklevel, index = 'NODF')))
NODF_nulls <- unlist(lapply(NODF_nulls, networklevel, index = 'NODF'))
net <- cophy[[3]] # the network
# uncorrected NODF
NODF_raw <- networklevel(net, index = 'NODF')
# create nulls for nestedness
nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
# calculate nestedness for the null networks
NODF_nulls <- unlist(lapply(NODF_nulls, networklevel, index = 'NODF'))
NODF_nulls <- unlist(lapply(nulls_r2d, networklevel, index = 'NODF'))
hist(NODF_nulls)
# create nulls for nestedness
nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 1000)
# calculate nestedness for the null networks
NODF_nulls <- unlist(lapply(nulls_r2d, networklevel, index = 'NODF'))
hist(NODF_nulls)
hist(NODF_nulls)
# create nulls for nestedness
nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 10000)
# calculate nestedness for the null networks
NODF_nulls <- unlist(lapply(nulls_r2d, networklevel, index = 'NODF'))
hist(NODF_nulls)
# uncorrected modularity
mod_raw <- modularity_bin(net)
library(igraph)
# uncorrected modularity
mod_raw <- modularity_bin(net)
modularity_bin <- function(net){
inc <- graph_from_biadjacency_matrix(net)
inc <- cluster_walktrap(inc)
temp <- igraph::modularity(inc)
return(temp)
}
# uncorrected modularity
mod_raw <- modularity_bin(net)
# create null networks through randomization (this has been done for NODF above so it is not done again)
# nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
# calculate nestedness for the null networks
mod_nulls <- unlist(lapply(nulls_r2d, modularity_bin))
# z-standardization
mod_z <- (mod_raw - mean(mod_nulls))/sd(mod_nulls)
NODF_z
# z-standardization
NODF_z <- (NODF_raw - mean(NODF_nulls))/sd(NODF_nulls)
SS_NODF_modularity <- function(cophy){
net <- cophy[[3]] # the network
# uncorrected NODF
NODF_raw <- networklevel(net, index = 'NODF')
# create null networks through randomization
nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
# calculate nestedness for the null networks
NODF_nulls <- unlist(lapply(nulls_r2d, networklevel, index = 'NODF'))
# z-standardization
NODF_z <- (NODF_raw - mean(NODF_nulls))/sd(NODF_nulls)
# uncorrected modularity
mod_raw <- modularity_bin(net)
# create null networks through randomization (this has been done for NODF above so it is not done again)
# nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
# calculate nestedness for the null networks
mod_nulls <- unlist(lapply(nulls_r2d, modularity_bin))
# z-standardization
mod_z <- (mod_raw - mean(mod_nulls))/sd(mod_nulls)
return(c(
NODF_raw,
NODF_z,
mod_raw,
mod_z,
)) # with z-standardization
}
test <- lapply(cophy_multi, SS_NODF_modularity)
SS_NODF_modularity <- function(cophy){
net <- cophy[[3]] # the network
# uncorrected NODF
NODF_raw <- networklevel(net, index = 'NODF')
# create null networks through randomization
nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
# calculate nestedness for the null networks
NODF_nulls <- unlist(lapply(nulls_r2d, networklevel, index = 'NODF'))
# z-standardization
NODF_z <- (NODF_raw - mean(NODF_nulls))/sd(NODF_nulls)
# uncorrected modularity
mod_raw <- modularity_bin(net)
# create null networks through randomization (this has been done for NODF above so it is not done again)
# nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
# calculate nestedness for the null networks
mod_nulls <- unlist(lapply(nulls_r2d, modularity_bin))
# z-standardization
mod_z <- (mod_raw - mean(mod_nulls))/sd(mod_nulls)
return(c(
NODF_raw,
NODF_z,
mod_raw,
mod_z
)) # with z-standardization
}
lapply(cophy_multi, modularity_bin)
lapply(cophy_multi, SS_NODF_modularity)
# apply the function to all the simulated co-phylogenetic systems
SS_phylo <- lapply(cophy_multi, SS_phylo_ntips_PD)
# apply the function to all the simulated co-phylogenetic systems
SS_network <- lapply(cophy_multi, SS_NODF_modularity)
library(vegan)
# all summary statistics can be computed from these three objects
tree1 <- cophy[[1]] # the host tree
tree2 <- cophy[[2]] # the symbiont tree
net <- cophy[[3]] # the network
# calculate UniFrac distances for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(net, tree1, alpha=c(0, 0.5, 1))$unifracs
??GUniFrac
library(GUniFrac)
install.packages(GUniFrac)
install.packages('GUniFrac')
library(GUniFrac)
# calculate UniFrac distances for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(net, tree1, alpha=c(0, 0.5, 1))$unifracs
# calculate UniFrac distances for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
unifracs
dw_host <- unifracs_host[, , "d_1"]		# Weighted UniFrac
dw_host <- unifracs[, , "d_1"]		# Weighted UniFrac
du_host <- unifracs[, , "d_UW"]		# Unweighted UniFrac
dv_host <- unifracs[, , "d_VAW"]		# Variance adjusted weighted UniFrac
d0_host <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0
d5_host <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
?GUniFrac
dw
dw <- unifracs[, , "d_1"]		# Weighted UniFrac
du <- unifracs[, , "d_UW"]		# Unweighted UniFrac
dv <- unifracs[, , "d_VAW"]		# Variance adjusted weighted UniFrac
d0 <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0
d5 <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
dw
dw/d0
dw/du
duw/d0
du/d0
dw/d0
class(unifracs)
unifracs[1]
unifracs[2]
unifracs
## Not run:
data(throat.otu.tab)
data(throat.tree)
data(throat.meta)
groups <- throat.meta$SmokingStatus
# Rarefaction
otu.tab.rff <- Rarefy(throat.otu.tab)$otu.tab.rff
otu.tab.rff
max(otu.tab.rff)
# Calculate the UniFracs
unifracs <- GUniFrac(otu.tab.rff, throat.tree)$unifracs
dw <- unifracs[, , "d_1"]		# Weighted UniFrac
du <- unifracs[, , "d_UW"]		# Unweighted UniFrac
d0 <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0
d5 <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
dw/du
# all summary statistics can be computed from these three objects
tree1 <- cophy[[1]] # the host tree
tree2 <- cophy[[2]] # the symbiont tree
net <- cophy[[3]] # the network
# first, prune the trees to keep only extant tips
tree1 <- keep.tip(tree1, rownames(net))
tree2 <- keep.tip(tree2, colnames(net))
# calculate UniFrac distances for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
# all summary statistics can be computed from these three objects
tree1 <- cophy[[1]] # the host tree
tree2 <- cophy[[2]] # the symbiont tree
net <- cophy[[3]] # the network
# first, prune host tree to keep only extant tips
tree1 <- keep.tip(tree1, rownames(net))
# calculate UniFrac distances for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
# compute the phylogenetic distance matrix for the host tree
PD_mat1 <- cophenetic.phylo(tree1)
?mantel
# compute the phylogenetic distance matrix for the host tree
PD_mat1 <- cophenetic.phylo(tree1)
mantel_w <- mantel(dw, PD_mat1, method="pearson", permutations=1000)
# compute UniFrac distance matrices for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
dw <- unifracs[, , "d_1"]		# Weighted UniFrac
du <- unifracs[, , "d_UW"]		# Unweighted UniFrac
d0 <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0
d5 <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
# compute the phylogenetic distance matrix for the host tree
PD_mat1 <- cophenetic.phylo(tree1)
mantel_w <- mantel(dw, PD_mat1, method="pearson", permutations=1000)
length(tree1$tip.label)
# compute the phylogenetic distance matrix for the host tree
PD_mat1 <- cophenetic.phylo(tree2) # note that this is the symniont tree, not the host tree!
tree2 <- keep.tip(tree2, rownames(net))
# all summary statistics can be computed from these three objects
tree1 <- cophy[[1]] # the host tree
tree2 <- cophy[[2]] # the symbiont tree
net <- cophy[[3]] # the network
# first, prune host tree to keep only extant tips
tree1 <- keep.tip(tree1, rownames(net))
tree2 <- keep.tip(tree2, colnames(net))
# compute UniFrac distance matrices for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
dw <- unifracs[, , "d_1"]		# Weighted UniFrac
du <- unifracs[, , "d_UW"]		# Unweighted UniFrac
d0 <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0
d5 <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
# compute the phylogenetic distance matrix for the host tree
PD_mat1 <- cophenetic.phylo(tree2) # note that this is the symniont tree, not the host tree!
mantel_w <- mantel(dw, PD_mat1, method="pearson", permutations=1000)
mantel_w
mantel_w$call
# compute the phylogenetic distance matrix for the host tree
PD_mat2 <- cophenetic.phylo(tree2) # note that this is the symniont tree, not the host tree!
# compute the Mantel correlation statistic and its significance
mantel_w <- mantel(dw, PD_mat2, method="pearson", permutations=1000)
mantel_u <- mantel(du, PD_mat2, method="pearson", permutations=1000)
mantel_0 <- mantel(d0, PD_mat2, method="pearson", permutations=1000)
mantel_5 <- mantel(d5, PD_mat2, method="pearson", permutations=1000)
library(GUniFrac)
library(vegan)
# a function that computes the mantel correlation
SS_mantel <- function(cophy){
# all summary statistics can be computed from these three objects
tree1 <- cophy[[1]] # the host tree
tree2 <- cophy[[2]] # the symbiont tree
net <- cophy[[3]] # the network
# first, prune host tree to keep only extant tips
tree1 <- keep.tip(tree1, rownames(net))
tree2 <- keep.tip(tree2, colnames(net))
# compute UniFrac distance matrices for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
dw <- unifracs[, , "d_1"]		# Weighted UniFrac
du <- unifracs[, , "d_UW"]		# Unweighted UniFrac
d0 <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0
d5 <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
# compute the phylogenetic distance matrix for the host tree
PD_mat2 <- cophenetic.phylo(tree2) # note that this is the symniont tree, not the host tree!
# compute the Mantel correlation statistic and its significance
mantel_w <- mantel(dw, PD_mat2, method="pearson", permutations=1000)
mantel_u <- mantel(du, PD_mat2, method="pearson", permutations=1000)
mantel_0 <- mantel(d0, PD_mat2, method="pearson", permutations=1000)
mantel_5 <- mantel(d5, PD_mat2, method="pearson", permutations=1000)
return(c(
mantel_w$statistic,
mantel_u$statistic,
mantel_0$statistic,
mantel_5$statistic,
mantel_w$signif,
mantel_u$signif,
mantel_0$signif,
mantel_5$signif,
))
}
# apply the function to all simulated co-phylogenetic systems
SS_mantel_stat_signif <- lapply(cophy_multi, SS_mantel)
# a function that computes the mantel correlation
SS_mantel <- function(cophy){
# all summary statistics can be computed from these three objects
tree1 <- cophy[[1]] # the host tree
tree2 <- cophy[[2]] # the symbiont tree
net <- cophy[[3]] # the network
# first, prune host tree to keep only extant tips
tree1 <- keep.tip(tree1, rownames(net))
tree2 <- keep.tip(tree2, colnames(net))
# compute UniFrac distance matrices for hosts, i.e., dissimilarity in interaction partners         for hosts
unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
dw <- unifracs[, , "d_1"]		# Weighted UniFrac
du <- unifracs[, , "d_UW"]		# Unweighted UniFrac
d0 <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0
d5 <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
# compute the phylogenetic distance matrix for the host tree
PD_mat2 <- cophenetic.phylo(tree2) # note that this is the symniont tree, not the host tree!
# compute the Mantel correlation statistic and its significance
mantel_w <- mantel(dw, PD_mat2, method="pearson", permutations=1000)
mantel_u <- mantel(du, PD_mat2, method="pearson", permutations=1000)
mantel_0 <- mantel(d0, PD_mat2, method="pearson", permutations=1000)
mantel_5 <- mantel(d5, PD_mat2, method="pearson", permutations=1000)
return(c(
mantel_w$statistic,
mantel_u$statistic,
mantel_0$statistic,
mantel_5$statistic,
mantel_w$signif,
mantel_u$signif,
mantel_0$signif,
mantel_5$signif
))
}
# apply the function to all simulated co-phylogenetic systems
SS_mantel_stat_signif <- lapply(cophy_multi, SS_mantel)
SS_combined <- NULL
SS_combined <- data.frame(NULL)
SS_combined$ntip1 <- lapply(SS_phylo, function(x) x[1])
lapply(SS_phylo, function(x) x[1])
SS_combined <- data.frame(NULL)
SS_combined$ntip1 <- unlist(lapply(SS_phylo, function(x) x[1]))
unlist(lapply(SS_phylo, function(x) x[1]))
SS_combined <- data.frame(
ntip1 = unlist(lapply(SS_phylo, function(x) x[1]))
)
SS_combined <- data.frame(
ntip1 = unlist(lapply(SS_phylo, function(x) x[1])),
ntip2 = unlist(lapply(SS_phylo, function(x) x[2])),
PD1 = unlist(lapply(SS_phylo, function(x) x[3])),
PD2 = unlist(lapply(SS_phylo, function(x) x[4])),
NODF_raw = unlist(lapply(SS_network, function(x) x[1])),
NODF_z = unlist(lapply(SS_network, function(x) x[2])),
mod_raw = unlist(lapply(SS_network, function(x) x[3])),
mod_z = unlist(lapply(SS_network, function(x) x[4])),
mantel_w$stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[1])),
SS_combined <- data.frame(
ntip1 = unlist(lapply(SS_phylo, function(x) x[1])),
ntip2 = unlist(lapply(SS_phylo, function(x) x[2])),
PD1 = unlist(lapply(SS_phylo, function(x) x[3])),
PD2 = unlist(lapply(SS_phylo, function(x) x[4])),
NODF_raw = unlist(lapply(SS_network, function(x) x[1])),
NODF_z = unlist(lapply(SS_network, function(x) x[2])),
mod_raw = unlist(lapply(SS_network, function(x) x[3])),
mod_z = unlist(lapply(SS_network, function(x) x[4])),
mantel_w_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[1])),
mantel_u_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[2])),
mantel_0_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[3])),
mantel_0.5_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[4])),
mantel_w_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[5])),
mantel_u_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[6])),
mantel_0_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[7])),
mantel_0.5_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[8]))
)
SS_combined$ntip1 <- unlist(lapply(SS_phylo, function(x) x[1]))
SS_combined <- data.frame(
ntip1 = unlist(lapply(SS_phylo, function(x) x[1])),
ntip2 = unlist(lapply(SS_phylo, function(x) x[2])),
PD1 = unlist(lapply(SS_phylo, function(x) x[3])),
PD2 = unlist(lapply(SS_phylo, function(x) x[4])),
NODF_raw = unlist(lapply(SS_network, function(x) x[1])),
NODF_z = unlist(lapply(SS_network, function(x) x[2])),
mod_raw = unlist(lapply(SS_network, function(x) x[3])),
mod_z = unlist(lapply(SS_network, function(x) x[4])),
mantel_w_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[1])),
mantel_u_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[2])),
mantel_0_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[3])),
mantel_0.5_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[4])),
mantel_w_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[5])),
mantel_u_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[6])),
mantel_0_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[7])),
mantel_0.5_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[8]))
)
# Load necessary libraries
library(GGally)
library(ggplot2)
# Create a pair plot
ggpairs(SS_combined)
SS_phylo_dat <- data.frame(
ntip1 = unlist(lapply(SS_phylo, function(x) x[1])),
ntip2 = unlist(lapply(SS_phylo, function(x) x[2])),
PD1 = unlist(lapply(SS_phylo, function(x) x[3])),
PD2 = unlist(lapply(SS_phylo, function(x) x[4]))
)
SS_network_dat <- data.frame(
NODF_raw = unlist(lapply(SS_network, function(x) x[1])),
NODF_z = unlist(lapply(SS_network, function(x) x[2])),
mod_raw = unlist(lapply(SS_network, function(x) x[3])),
mod_z = unlist(lapply(SS_network, function(x) x[4]))
)
SS_mantel_dat <- data.frame(
mantel_w_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[1])),
mantel_u_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[2])),
mantel_0_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[3])),
mantel_0.5_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[4])),
mantel_w_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[5])),
mantel_u_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[6])),
mantel_0_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[7])),
mantel_0.5_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[8]))
)
warning: false
warning: false
# Load necessary libraries
library(GGally)
library(ggplot2)
# Create a pair plot
ggpairs(SS_phylo)
# Load necessary libraries
library(GGally)
library(ggplot2)
# Create a pair plot
ggpairs(SS_phylo_dat)
ggpairs(SS_network_dat)
ggpairs(SS_mantel_dat)
# Load necessary libraries
library(GGally)
library(ggplot2)
# Create a pair plot
ggpairs(SS_phylo_dat)
# Create a pair plot
ggpairs(SS_phylo_dat)
# Create a pair plot
ggpairs(SS_network_dat)
# Create a pair plot
ggpairs(SS_mantel_dat)
---
title: "Generating outputs from TreeDucken for approximate Bayesian computation - an example implementation"
---
title: "Generating outputs from TreeDucken for approximate Bayesian computation - an example implementation"
---
title: "Generating outputs from TreeDucken for approximate Bayesian computation - an example implementation"
title: "Generating
dfsdf
fsdfsd
sdfdddfdfsedefe
)
}
}
rerewr
#set.seed(34)
cophy_obj <- NULL
# time
time <- 2
# host speciation rate
lambda_H <- rexp(n=1)
# symbiont speciation rate
lambda_S <- rexp(n=1)
# cospeciation rate
lambda_C <- rexp(n=1)
# host expansion rate
exp_H <- rexp(n=1)
# host turnover and extinction rates
mu_H_frac <- runif(1, min = 0, max = 1)
mu_H <- mu_H_frac * (lambda_H + lambda_C)
# symbiont turnover and extinction rates
mu_S_frac <- runif(1, min = 0, max = 1)
mu_S <- mu_S_frac * (lambda_S + lambda_C)
lambda_total_H <- lambda_H + lambda_C
lambda_total_S <- lambda_S + lambda_C
# calculate the expected number of tips for the host and symbiont trees
H_tips <- ave_tips_st(lambda = lambda_total_H, mu = mu_H, t = time)
#set.seed(34)
cophy_obj <- NULL
# time
time <- 2
# host speciation rate
lambda_H <- rexp(n=1)
# symbiont speciation rate
lambda_S <- rexp(n=1)
# cospeciation rate
lambda_C <- rexp(n=1)
# host expansion rate
exp_H <- rexp(n=1)
# host turnover and extinction rates
mu_H_frac <- runif(1, min = 0, max = 1)
mu_H <- mu_H_frac * (lambda_H + lambda_C)
# symbiont turnover and extinction rates
mu_S_frac <- runif(1, min = 0, max = 1)
mu_S <- mu_S_frac * (lambda_S + lambda_C)
lambda_total_H <- lambda_H + lambda_C
lambda_total_S <- lambda_S + lambda_C
# calculate the expected number of tips for the host and symbiont trees
H_tips <- ave_tips_st(lambda = lambda_total_H, mu = mu_H, t = time)
?ave_tips_st
library(treeducken)
#set.seed(34)
cophy_obj <- NULL
# time
time <- 2
# host speciation rate
lambda_H <- rexp(n=1)
# symbiont speciation rate
lambda_S <- rexp(n=1)
# cospeciation rate
lambda_C <- rexp(n=1)
# host expansion rate
exp_H <- rexp(n=1)
# host turnover and extinction rates
mu_H_frac <- runif(1, min = 0, max = 1)
mu_H <- mu_H_frac * (lambda_H + lambda_C)
# symbiont turnover and extinction rates
mu_S_frac <- runif(1, min = 0, max = 1)
mu_S <- mu_S_frac * (lambda_S + lambda_C)
lambda_total_H <- lambda_H + lambda_C
lambda_total_S <- lambda_S + lambda_C
# calculate the expected number of tips for the host and symbiont trees
H_tips <- ave_tips_st(lambda = lambda_total_H, mu = mu_H, t = time)
S_tips <- ave_tips_st(lambda = lambda_total_S, mu = mu_S, t = time)
cophy_obj <- sim_cophyBD(hbr = lambda_H,
hdr = mu_H,
sbr = lambda_S,
sdr = mu_S,
cosp_rate =lambda_C,
host_exp_rate = exp_H,
time_to_sim = time,
numbsim = 1)
# visualization using ape, transformation of the association matrix needed
ass_mat_trans <- NULL
ass_mat <- cophy_obj[[1]][[3]]
for(i in 1:nrow(ass_mat)){
for (j in 1:ncol(ass_mat)){
if (ass_mat[i,j] == 1)
ass_mat_trans <- rbind(ass_mat_trans, c(rownames(ass_mat)[i], colnames(ass_mat)[j]))
}
}
cophylo_plot <- cophylo(cophy_obj[[1]][[1]], cophy_obj[[1]][[2]], assoc = ass_mat_trans)
