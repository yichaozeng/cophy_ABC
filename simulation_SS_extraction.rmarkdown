---
title: "Generating outputs from TreeDucken for approximate Bayesian computation - an example implementation"
format: pdf
editor: visual
---



We use the TreeDucken package for simulating co-phylogenies. The outputs of this model includes two trees, one for the host and other for the symbiont, and the association between the tips of the two trees in the format of a matrix.

We first visualize the co-phylogeny with the TreeDucken package itself (the last line is commented out to omit the plot).



```{r}
# For R/4.4.0}

# install.packages("htmlwidgets")
# install.packages("devtools")
library(devtools)
# install_version("apTreeshape", version = "1.5-0.1")
library(apTreeshape)
# install_version("treeducken", version = "1.1.0")
library(treeducken)
library(phytools)
library(geiger)

set.seed(54)

# host speciation
lambda_H <- rexp(n=1)

# host extinction rate
mu_H <- 0.3

# cospeciation rate
lambda_C <- rexp(n=1)

# time
time <- 2

# symbiont speciation rate
lambda_S <- rexp(n=1)

# symbiont extinction rate
mu_S <- 0.3

lambda_total_H <- lambda_H + lambda_C
lambda_total_S <- lambda_S + lambda_C

# calculate the expected number of tips for the host and symbiont trees
H_tips <- ave_tips_st(lambda = lambda_total_H, mu = mu_H, t = time)
S_tips <- ave_tips_st(lambda = lambda_total_S, mu = mu_S, t = time)

cophy_obj <- sim_cophyBD(hbr = lambda_H,
                           hdr = mu_H,
                           sbr = lambda_S,
                           sdr = mu_S,
                           cosp_rate =lambda_C,
                           host_exp_rate = 0.0,
                           time_to_sim = time,
                           numbsim = 1)

# visualization using treeDucken, with imperfections
# plot.cophy(cophy_obj[[1]], col = "orange", lty = "dotted", lwd = 2)
```



Alternatively, the co-phylogeny can be visualize using phytools (the last line is commented out to omit the plot).



```{r}
# visualization using ape or phytools, transformation of the association matrix needed
ass_mat_trans <- NULL
ass_mat <- cophy_obj[[1]][[3]]
for(i in 1:nrow(ass_mat)){
  for (j in 1:ncol(ass_mat)){
    if (ass_mat[i,j] == 1)
      
      ass_mat_trans <- rbind(ass_mat_trans, c(rownames(ass_mat)[i], colnames(ass_mat)[j]))
    
  }
}

# using ape / phytools
cophylo_plot <- cophylo(cophy_obj[[1]][[1]], cophy_obj[[1]][[2]], assoc = ass_mat_trans)
#plot(cophylo_plot)
```



However, it turns out base ape does a good job plotting co-phylogenies as well, which is shown here.



```{r}
plot(cophylo_plot,link.type="curved",link.lwd=4,
     link.lty="solid",link.col=make.transparent("red",0.25))
```



To use the model for ABC, we slightly modify the way the model is parameterized. Instead of directly specifying the values of host and symbiont extinction rates, we define each of these two extinction rates as a fraction (between 0 and 1) of the correponding total speciation rate. We do this because TreeDucken returns an error when host extinction rate (mu_H) exceeds host total speciation rate (lambda_H + lambda_C). In contrast, it does not return an error when symbiont extinction rate (mu_S) exceeds symbiont total speciation rate (lambda_S + lambda_C), but we avoid this anyway since a symbiont clade undergoing faster extinction than speciation is less likely to persist to today.



```{r}
  #set.seed(34)
  
  cophy_obj <- NULL
  
  # time
  time <- 2
  
  # host speciation rate
  lambda_H <- rexp(n=1)
  
  # symbiont speciation rate
  lambda_S <- rexp(n=1)

  # cospeciation rate
  lambda_C <- rexp(n=1)
  
  # host expansion rate
  exp_H <- rexp(n=1)
  
  # host turnover and extinction rates
  mu_H_frac <- runif(1, min = 0, max = 1)
  mu_H <- mu_H_frac * (lambda_H + lambda_C)
  
  # symbiont turnover and extinction rates
  mu_S_frac <- runif(1, min = 0, max = 1)
  mu_S <- mu_S_frac * (lambda_S + lambda_C)
  
  lambda_total_H <- lambda_H + lambda_C
  lambda_total_S <- lambda_S + lambda_C
  
  # calculate the expected number of tips for the host and symbiont trees
  H_tips <- ave_tips_st(lambda = lambda_total_H, mu = mu_H, t = time)
  S_tips <- ave_tips_st(lambda = lambda_total_S, mu = mu_S, t = time)
  
```



Simulate multiple co-phylogenetic systems using the *same* parameters.



```{r}
cophy_multi <- sim_cophyBD(hbr = lambda_H,
                             hdr = mu_H,
                             sbr = lambda_S,
                             sdr = mu_S,
                             cosp_rate =lambda_C,
                             host_exp_rate = exp_H,
                             time_to_sim = time,
                             numbsim = 100)

print(c(lambda_H,
      mu_H,
      lambda_S,
      mu_S,
      lambda_C,
      exp_H,
      time
      ))
```



Below we show how to quantify the summary statistics for the co-phylogenetic systems.

We start with phylogenetic summary statistics represented by number of extant lineages and phylogenetic distance.



```{r}
# a function that computes the number of tips and phylogenetic distance
SS_phylo_ntips_PD <- function(cophy){
  
  # all summary statistics can be computed from these three objects
  tree1 <- cophy[[1]] # the host tree
  tree2 <- cophy[[2]] # the symbiont tree
  net <- cophy[[3]] # the network
  
  # first, prune the trees to keep only extant tips
  tree1 <- keep.tip(tree1, rownames(net))
  tree2 <- keep.tip(tree2, colnames(net))
  
  # mean phylogenetic distance to the closest relative
  PD_mat1 <- cophenetic.phylo(tree1)
  # or temp <- get_all_pairwise_distances(phy, only_clades = 1:length(phy$tip.label)) for large tree files
  diag(PD_mat1) <- NA
  pd1 <- apply(PD_mat1, 1, min, na.rm=T)
  
  PD_mat2 <- cophenetic.phylo(tree2)
  # or temp <- get_all_pairwise_distances(phy, only_clades = 1:length(phy$tip.label)) for large tree files
  diag(PD_mat2) <- NA
  pd2 <- apply(PD_mat2, 1, min, na.rm=T)
  
  return(c(
      Ntip(tree1),
      Ntip(tree2),
      mean(pd1),
      mean(pd2) 
    )
  )
  
}


# apply the function to all the simulated co-phylogenetic systems
SS_phylo <- lapply(cophy_multi, SS_phylo_ntips_PD)

```



Before we move on to network properties including nestedness and modularity, it is helpful to visualize an example network.



```{r}
library(bipartite)
library(igraph)
library(ggplot2)
library(GGally)

# visualize individual webs
net <- cophy_multi[[2]][[3]]
#plotweb(net, text.rot=90, col.low = "green", col.high = "blue")

# creating network object for plotting
net_obj <- network(net, matrix.type = "bipartite",
               directed = FALSE, ignore.eval = FALSE)
# plotting
col = c("actor" = "tomato", "event" = "steelblue")

ggnet2(net_obj, node.size = 5, color = "mode", palette = col, edge.color = "gray70",
       edge.size = 1, mode = "kamadakawai", legend.position = 'none',
       label = T, label.color = "white", label.size = 2.5,
       shape = c(rep(15, nrow(net)),
                 rep(16, ncol(net)))
       )
```



Now we compute the raw and z-standardized network properties.



```{r}
# Function for calculating binary modularity
modularity_bin <- function(net){
  inc <- graph_from_biadjacency_matrix(net)
  inc <- cluster_walktrap(inc)
  temp <- igraph::modularity(inc)
  return(temp)
}

# a function that computes uncorrected and corrected nestedness (NODF) and modularity
SS_NODF_modularity <- function(cophy){
    net <- cophy[[3]] # the network
    
    # uncorrected NODF
    NODF_raw <- networklevel(net, index = 'NODF')
    # create null networks through randomization
    nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
    # calculate nestedness for the null networks
    NODF_nulls <- unlist(lapply(nulls_r2d, networklevel, index = 'NODF'))
    # z-standardization
    NODF_z <- (NODF_raw - mean(NODF_nulls))/sd(NODF_nulls)
    
    # uncorrected modularity
    mod_raw <- modularity_bin(net)
    # create null networks through randomization (this has been done for NODF above so it is not done again)
    # nulls_r2d <- nullmodel(net, method = "shuffle.web", N = 100)
    # calculate nestedness for the null networks
    mod_nulls <- unlist(lapply(nulls_r2d, modularity_bin))
    # z-standardization
    mod_z <- (mod_raw - mean(mod_nulls))/sd(mod_nulls)
    
    return(c(
      NODF_raw,
      NODF_z,
      mod_raw,
      mod_z
    )) # with z-standardization
    
}


# apply the function to all the simulated co-phylogenetic systems
SS_network <- lapply(cophy_multi, SS_NODF_modularity)

```



Now, we move on to properties regarding both the phylogenies and the network - different measures of mantel correlation betweeb the *phylogenetic distance* matrix and the *interaction partner dissimilarity* matrix.



```{r}
library(GUniFrac)
library(vegan)

# a function that computes the mantel correlation
SS_mantel <- function(cophy){
      
      # all summary statistics can be computed from these three objects
      tree1 <- cophy[[1]] # the host tree
      tree2 <- cophy[[2]] # the symbiont tree
      net <- cophy[[3]] # the network
      
      # first, prune host tree to keep only extant tips
      tree1 <- keep.tip(tree1, rownames(net))
      tree2 <- keep.tip(tree2, colnames(net))
      
      # compute UniFrac distance matrices for hosts, i.e., dissimilarity in interaction partners         for hosts
      unifracs <- GUniFrac(t(net), tree1, alpha=c(0, 0.5, 1))$unifracs
      dw <- unifracs[, , "d_1"]		# Weighted UniFrac
      du <- unifracs[, , "d_UW"]		# Unweighted UniFrac	
      d0 <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0  
      d5 <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5
      
      # compute the phylogenetic distance matrix for the host tree
      PD_mat2 <- cophenetic.phylo(tree2) # note that this is the symniont tree, not the host tree!
      
      # compute the Mantel correlation statistic and its significance
      mantel_w <- mantel(dw, PD_mat2, method="pearson", permutations=1000)
      mantel_u <- mantel(du, PD_mat2, method="pearson", permutations=1000)
      mantel_0 <- mantel(d0, PD_mat2, method="pearson", permutations=1000)
      mantel_5 <- mantel(d5, PD_mat2, method="pearson", permutations=1000)
      
      return(c(
        mantel_w$statistic,
        mantel_u$statistic,
        mantel_0$statistic,
        mantel_5$statistic,
        
        mantel_w$signif,
        mantel_u$signif,
        mantel_0$signif,
        mantel_5$signif
      ))
  
}


# apply the function to all simulated co-phylogenetic systems
SS_mantel_stat_signif <- lapply(cophy_multi, SS_mantel)
```



Now we combine the summary statistics we have calculated into a dataframe for visualization.



```{r}
SS_phylo_dat <- data.frame(
  ntip1 = unlist(lapply(SS_phylo, function(x) x[1])),
  ntip2 = unlist(lapply(SS_phylo, function(x) x[2])),
  PD1 = unlist(lapply(SS_phylo, function(x) x[3])),
  PD2 = unlist(lapply(SS_phylo, function(x) x[4]))
)

SS_network_dat <- data.frame( 
  NODF_raw = unlist(lapply(SS_network, function(x) x[1])),
  NODF_z = unlist(lapply(SS_network, function(x) x[2])),
  mod_raw = unlist(lapply(SS_network, function(x) x[3])),
  mod_z = unlist(lapply(SS_network, function(x) x[4]))
)

SS_mantel_dat <- data.frame( 
  mantel_w_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[1])),
  mantel_u_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[2])),
  mantel_0_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[3])),
  mantel_0.5_stat = unlist(lapply(SS_mantel_stat_signif, function(x) x[4])),
  mantel_w_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[5])),
  mantel_u_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[6])),
  mantel_0_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[7])),
  mantel_0.5_signif = unlist(lapply(SS_mantel_stat_signif, function(x) x[8]))
)
```



Visualize the multi-dimensional joint distributions of the summary statistics regarding the *two phylogenies*.



```{r warning: false}

# Load necessary libraries
library(GGally)
library(ggplot2)

# Create a pair plot
ggpairs(SS_phylo_dat)
```



Visualize the multi-dimensional joint distributions of the summary statistics regarding the *network*.



```{r}
# Create a pair plot
ggpairs(SS_network_dat)
```



Visualize the multi-dimensional joint distributions of the summary statistics regarding both the *two phylogenies and the network*.



```{r}
# Create a pair plot
ggpairs(SS_mantel_dat)
```



Here it may be necessary to do a sanity check to make sure the simulated co-phylogenies are within the ranges of real networks.



```{r}

```

```{r}

```

